<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ song.base_name }} - {{ branding.title }}</title>
    <meta name="description" content="{{ branding.description }}">
    <link rel="icon" href="{{ branding.favicon or '/static/favicon.ico' }}">
    <link rel="stylesheet" href="/static/style.css">
    <style>
        /* Play page specific styles to ensure proper rendering */
        .play-page .visualizer-container {
            width: 100%;
            height: 120px;
            margin-bottom: 16px;
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--bg-secondary);
        }

        .play-page .visualizer-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .play-page .progress-container {
            position: relative;
            height: 60px;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .play-page .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-warm));
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .play-page .playhead {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background: var(--text-primary);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
            left: 0;
        }

        .play-page .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .play-page .controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        .play-page .control-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .play-page .control-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .play-page .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .play-page .volume-icon {
            font-size: 1rem;
        }

        .play-page .volume-slider {
            width: 100px;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
        }

        .play-page .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .play-subtitle {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 24px;
        }
    </style>
</head>

<body class="play-page" style="--accent-color: {{ branding.accent_color or '#ffffff' }}">
    <div class="container">
        <h1 id="pageTitle">{{ song.base_name }}</h1>
        <p class="play-subtitle">{{ song.filename }}</p>

        <div class="card">
            <!-- Visualizer -->
            <div class="visualizer-container">
                <canvas id="visualizer"></canvas>
            </div>

            <!-- Audio Controls -->
            <div class="audio-controls">
                <div class="progress-container" id="progressBar">
                    <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                </div>

                <div class="time-display">
                    <span id="currentTime">0:00</span>
                    <span id="totalTime">0:00</span>
                </div>

                <div class="controls-row">
                    <button id="playBtn" class="control-btn">&#9654;</button>
                    <div class="volume-control">
                        <span class="volume-icon">&#9673;</span>
                        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.01"
                            value="1">
                    </div>
                    <button id="castBtn" class="control-btn" style="display: none;" title="Cast">&#8984;</button>
                </div>
            </div>

            <audio id="audioPlayer" preload="auto" crossorigin="anonymous"></audio>
        </div>

        <div class="nav-footer">
            <a href="/" class="nav-link">← Back</a>
            <a href="/results" class="nav-link">Results</a>
        </div>
    </div>

    <script>
        window.VISUALIZER_MODE = '{{ branding.visualizer_mode or "bars" }}';
        window.VISUALIZER_COLOR = '{{ branding.visualizer_color or "" }}';
    </script>
    <script>
        class SimplePlayer {
            constructor(songId) {
                this.audio = document.getElementById('audioPlayer');
                this.playBtn = document.getElementById('playBtn');

                // Waveform elements
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.waveCtx = this.waveformCanvas ? this.waveformCanvas.getContext('2d') : null;
                this.waveData = null;

                this.currentTimeEl = document.getElementById('currentTime');
                this.totalTimeEl = document.getElementById('totalTime');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.castBtn = document.getElementById('castBtn');
                this.canvas = document.getElementById('visualizer');

                this.isPlaying = false;
                this.audioContext = null;
                this.analyser = null;

                // Cache accent color
                this.accentColor = getComputedStyle(document.body).getPropertyValue('--accent-color').trim() || '#a78bfa';

                this.init(songId);
            }

            init(songId) {
                this.audio.src = `/api/songs/${songId}/audio`;

                fetch(`/api/songs/${songId}/waveform`)
                    .then(res => res.json())
                    .then(data => {
                        this.waveData = data;
                        this.drawWaveform();
                    })
                    .catch(() => this.waveData = null);

                // Event listeners
                this.playBtn.addEventListener('click', () => this.togglePlay());

                if (this.waveformCanvas) {
                    this.waveformCanvas.addEventListener('click', (e) => this.seekFromEvent(e));
                }


                this.volumeSlider.addEventListener('input', () => {
                    // Use gainNode if available (for decoupled visualization)
                    const volume = parseFloat(this.volumeSlider.value);
                    if (this.gainNode) {
                        this.gainNode.gain.value = volume;
                    } else {
                        this.audio.volume = volume;
                    }
                });


                if (this.castBtn) {
                    this.castBtn.addEventListener('click', () => this.promptCast());
                }

                // Seek drag on canvas
                if (this.waveformCanvas) {
                    let isDragging = false;

                    const startDrag = (e) => {
                        isDragging = true;
                        this.seekFromEvent(e);
                    };

                    const endDrag = () => {
                        isDragging = false;
                    };

                    this.waveformCanvas.addEventListener('mousedown', startDrag);
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) this.seekFromEvent(e);
                    });
                    document.addEventListener('mouseup', endDrag);

                    // Hover effect tracking
                    this.hoverX = -1;
                    this.waveformCanvas.addEventListener('mousemove', (e) => {
                        const rect = this.waveformCanvas.getBoundingClientRect();
                        this.hoverX = e.clientX - rect.left;
                    });
                    this.waveformCanvas.addEventListener('mouseleave', () => {
                        this.hoverX = -1;
                    });

                    this.waveformCanvas.addEventListener('touchstart', (e) => {
                        startDrag(e.touches[0]);
                    }, { passive: true });
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        this.seekFromEvent(e.touches[0]);
                    }, { passive: true });
                    document.addEventListener('touchend', endDrag);

                    // Start render loop
                    this.animateWaveform();
                }

                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('loadedmetadata', () => {
                    this.totalTimeEl.textContent = this.formatTime(this.audio.duration);
                });
                this.audio.addEventListener('play', () => {
                    this.isPlaying = true;
                    this.playBtn.textContent = '❙❙';
                    if (!this.audioContext) this.setupVisualizer();
                    // Note: resume handled in togglePlay() with await
                });
                this.audio.addEventListener('pause', () => {
                    this.isPlaying = false;
                    this.playBtn.textContent = '▶';
                });

                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                        e.preventDefault();
                        this.togglePlay();
                    }
                });

                this.initCasting();
            }

            initCasting() {
                if (!this.castBtn) return;

                // Check if Remote Playback API is available
                if ('remote' in this.audio) {
                    this.audio.remote.watchAvailability((available) => {
                        this.castBtn.style.display = available ? 'flex' : 'none';
                    }).catch(() => {
                        // Fallback: always show cast button
                        this.castBtn.style.display = 'flex';
                    });
                } else {
                    this.castBtn.style.display = 'none';
                }
            }

            promptCast() {
                if ('remote' in this.audio) {
                    this.audio.remote.prompt().catch(err => {
                        console.log('Cast prompt error:', err);
                    });
                }
            }

            async togglePlay() {
                if (this.isPlaying) {
                    this.audio.pause();
                } else {
                    // Ensure AudioContext is running BEFORE playing
                    if (this.audioContext && this.audioContext.state !== 'running') {
                        try {
                            await this.audioContext.resume();
                        } catch (err) {
                            console.log('AudioContext resume failed:', err);
                        }
                    }
                    this.audio.play();
                }
            }

            seekFromEvent(e) {
                if (!this.waveformCanvas) return;
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = e.clientX !== undefined ? e.clientX : e.pageX;
                let percent = (x - rect.left) / rect.width;
                percent = Math.max(0, Math.min(1, percent));
                if (!isNaN(this.audio.duration)) {
                    this.audio.currentTime = percent * this.audio.duration;
                }
            }

            updateProgress() {
                if (!this.waveformCanvas) return;
                this.currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
                // Drawing handled by animation loop
            }

            animateWaveform() {
                this.drawWaveform();
                requestAnimationFrame(() => this.animateWaveform());
            }

            drawWaveform() {
                if (!this.waveCtx || !this.waveformCanvas) return;

                const width = this.waveformCanvas.offsetWidth;
                const height = this.waveformCanvas.offsetHeight;

                // Handle retina
                if (this.waveformCanvas.width !== width * window.devicePixelRatio) {
                    this.waveformCanvas.width = width * window.devicePixelRatio;
                    this.waveformCanvas.height = height * window.devicePixelRatio;
                    this.waveCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
                }

                // Clear (transparent background)
                this.waveCtx.clearRect(0, 0, width, height);

                // Use dummy data if not loaded yet
                const data = this.waveData || new Array(100).fill(0.1);
                const barWidth = width / data.length;
                const gap = 0.5; // Small gap

                const progress = this.audio.currentTime / this.audio.duration || 0;
                const progressX = progress * width;

                // Get accent color
                const accentColor = this.accentColor || '#a78bfa';

                // 1. Draw Unplayed Bars
                this.waveCtx.shadowBlur = 0;
                this.waveCtx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                for (let i = 0; i < data.length; i++) {
                    const val = data[i];
                    const x = i * barWidth;
                    const barHeight = Math.max(2, val * height);
                    const y = (height - barHeight) / 2;
                    this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                }

                // 2. Hover (Clipped)
                if (this.hoverX > progressX) {
                    this.waveCtx.save();
                    this.waveCtx.beginPath();
                    this.waveCtx.rect(progressX, 0, this.hoverX - progressX, height);
                    this.waveCtx.clip();

                    this.waveCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    for (let i = 0; i < data.length; i++) {
                        const val = data[i];
                        const x = i * barWidth;
                        if (x + barWidth < progressX) continue;
                        const barHeight = Math.max(2, val * height);
                        const y = (height - barHeight) / 2;
                        this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                    }
                    this.waveCtx.restore();
                }

                // 3. Played (Clipped with Glow)
                this.waveCtx.save();
                this.waveCtx.beginPath();
                this.waveCtx.rect(0, 0, progressX, height);
                this.waveCtx.clip();

                // Create gradient using accent color
                const playedGradient = this.waveCtx.createLinearGradient(0, 0, progressX, 0);
                playedGradient.addColorStop(0, '#ffffff'); // Start bright white
                playedGradient.addColorStop(1, accentColor);

                this.waveCtx.shadowColor = accentColor;
                this.waveCtx.shadowBlur = 6; // Stronger glow for play page
                this.waveCtx.fillStyle = playedGradient;

                for (let i = 0; i < data.length; i++) {
                    const val = data[i];
                    const x = i * barWidth;
                    if (x > progressX) break;
                    const barHeight = Math.max(2, val * height);
                    const y = (height - barHeight) / 2;
                    this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                }
                this.waveCtx.restore();

                // Draw playhead line with glow
                if (progress > 0 && progress < 1) {
                    this.waveCtx.shadowBlur = 10;
                    this.waveCtx.shadowColor = '#a78bfa';
                    this.waveCtx.strokeStyle = '#ffffff';
                    this.waveCtx.lineWidth = 2;
                    this.waveCtx.beginPath();
                    this.waveCtx.moveTo(progressX, 0);
                    this.waveCtx.lineTo(progressX, height);
                    this.waveCtx.stroke();
                    this.waveCtx.shadowBlur = 0;
                }
            }

            formatTime(sec) {
                if (isNaN(sec)) return '0:00';
                const m = Math.floor(sec / 60);
                const s = Math.floor(sec % 60);
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            setupVisualizer() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;

                // Create gain node for volume control AFTER analyser
                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = this.volumeSlider ? parseFloat(this.volumeSlider.value) : 1;

                const source = this.audioContext.createMediaElementSource(this.audio);
                // Route: source -> analyser -> gainNode -> destination
                source.connect(this.analyser);
                this.analyser.connect(this.gainNode);
                this.gainNode.connect(this.audioContext.destination);

                // Set audio element to full volume (gain controls output)
                this.audio.volume = 1;

                this.drawVisualizer();
            }

            drawVisualizer() {
                const ctx = this.canvas.getContext('2d');
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const frequencyData = new Uint8Array(bufferLength);
                const mode = window.VISUALIZER_MODE || 'bars';

                // Trail history for ghost effect
                const trailHistory = [];
                const maxTrails = 5;

                // Get accent color
                const accentColor = this.accentColor || '#a78bfa';

                // Helper: Draw smooth bezier curve
                const drawSmoothCurve = (points, mirror, height) => {
                    if (points.length < 2) return;
                    const centerY = height / 2;
                    const getY = (y) => mirror ? centerY + (centerY - y) : y;

                    ctx.moveTo(points[0].x, getY(points[0].y));
                    for (let i = 1; i < points.length - 1; i++) {
                        const xc = (points[i].x + points[i + 1].x) / 2;
                        const yc = (getY(points[i].y) + getY(points[i + 1].y)) / 2;
                        ctx.quadraticCurveTo(points[i].x, getY(points[i].y), xc, yc);
                    }
                    const last = points[points.length - 1];
                    ctx.lineTo(last.x, getY(last.y));
                };

                const draw = () => {
                    requestAnimationFrame(draw);

                    const container = this.canvas.parentElement;
                    const width = container.offsetWidth;
                    const height = container.offsetHeight;

                    // Set canvas size for retina
                    this.canvas.width = width * window.devicePixelRatio;
                    this.canvas.height = height * window.devicePixelRatio;
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                    // Clear with dark background
                    ctx.fillStyle = 'rgba(15, 15, 20, 0.4)';
                    ctx.fillRect(0, 0, width, height);

                    // Get appropriate data
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.analyser.getByteFrequencyData(frequencyData);

                    // Parse accent color to get HSL values for dynamic coloring
                    const accentHex = accentColor.replace('#', '');
                    const r = parseInt(accentHex.substr(0, 2), 16) / 255;
                    const g = parseInt(accentHex.substr(2, 2), 16) / 255;
                    const b = parseInt(accentHex.substr(4, 2), 16) / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h = 0;
                    if (max !== min) {
                        const d = max - min;
                        if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                        else if (max === g) h = ((b - r) / d + 2) / 6;
                        else h = ((r - g) / d + 4) / 6;
                    }
                    const accentHue = Math.round(h * 360);

                    // Draw bars first if mode is 'bars' or 'both'
                    if (mode === 'bars' || mode === 'both') {
                        const barCount = 64; // More bars for smoother look
                        const barWidth = (width / barCount) * 0.85;
                        const gap = (width / barCount) * 0.15;

                        for (let i = 0; i < barCount; i++) {
                            const idx = Math.floor(i * bufferLength / barCount);
                            const value = frequencyData[idx] / 255;
                            const barHeight = value * height * 0.9;
                            const x = i * (barWidth + gap);

                            if (mode === 'both') {
                                // In both mode: bars are a subtle glowing backdrop
                                const hueShift = (i / barCount) * 40 - 20;
                                const sat = 25 + value * 30;
                                const light = 20 + value * 25;

                                // Create vertical gradient for each bar
                                const barGrad = ctx.createLinearGradient(0, height, 0, height - barHeight);
                                barGrad.addColorStop(0, `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.6)`);
                                barGrad.addColorStop(1, `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.1)`);

                                ctx.fillStyle = barGrad;
                            } else {
                                // Bars-only mode: full vibrant bars
                                const hueShift = (i / barCount) * 30 - 15;
                                const sat = 50 + value * 40;
                                const light = 35 + value * 40;
                                ctx.fillStyle = `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.85)`;
                            }
                            ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                        }
                    }

                    // Draw oscilloscope if mode is 'wave' or 'both'
                    if (mode === 'wave' || mode === 'both') {
                        // Calculate average amplitude for reactive effects
                        let avgAmplitude = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            avgAmplitude += Math.abs(dataArray[i] - 128);
                        }
                        avgAmplitude = (avgAmplitude / bufferLength) / 128;

                        // Store current frame points
                        const currentPoints = [];
                        const sliceWidth = width / bufferLength;

                        for (let i = 0; i < bufferLength; i++) {
                            const v = dataArray[i] / 128.0;
                            const y = (v * height) / 2;
                            currentPoints.push({ x: i * sliceWidth, y });
                        }

                        // Add to trail history
                        trailHistory.unshift(currentPoints);
                        if (trailHistory.length > maxTrails) trailHistory.pop();

                        // Green oscilloscope: classic VU green → cyan complement
                        const isDefaultAccent = !accentColor || accentColor === '#ffffff' || accentColor === '';
                        const baseHue = isDefaultAccent ? 120 : accentHue; // VU meter green
                        const compHue = isDefaultAccent ? 180 : (accentHue + 180) % 360; // Cyan

                        // Draw trails (fading)
                        for (let t = trailHistory.length - 1; t >= 0; t--) {
                            const points = trailHistory[t];
                            const trailAlpha = (1 - t / maxTrails) * 0.3;

                            if (t > 0) {
                                ctx.strokeStyle = `hsla(${baseHue}, 50%, 50%, ${trailAlpha})`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                drawSmoothCurve(points, false, height);
                                ctx.stroke();
                            }
                        }

                        // TIME-BASED OSCILLATION - gradient slides back and forth
                        const time = Date.now() / 1000;
                        const gradientPhase = Math.sin(time * 0.5) * 0.3;
                        const gradientStart = Math.max(0, gradientPhase);
                        const gradientEnd = Math.min(1, 1 + gradientPhase);

                        // DYNAMIC REACTIVE GRADIENT with time-based movement
                        const gradient = ctx.createLinearGradient(width * gradientStart, 0, width * gradientEnd, 0);
                        const hueShift = avgAmplitude * 40 + Math.sin(time * 2) * 15;
                        const satBoost = 65 + avgAmplitude * 25;
                        const lightBoost = 50 + avgAmplitude * 25;

                        gradient.addColorStop(0, `hsl(${baseHue - hueShift}, ${satBoost}%, ${lightBoost}%)`);
                        gradient.addColorStop(0.25, `hsl(${baseHue}, ${satBoost + 10}%, ${lightBoost + 15}%)`);
                        gradient.addColorStop(0.5, `hsla(0, 0%, 100%, ${0.6 + avgAmplitude * 0.4})`);
                        gradient.addColorStop(0.75, `hsl(${compHue}, ${satBoost}%, ${lightBoost}%)`);
                        gradient.addColorStop(1, `hsl(${baseHue + hueShift}, ${satBoost}%, ${lightBoost}%)`);

                        // Draw main oscilloscope line with subtle glow
                        const glowColor = isDefaultAccent ? `hsl(${baseHue}, 60%, 60%)` : accentColor;
                        ctx.shadowColor = glowColor;
                        ctx.shadowBlur = 6 + avgAmplitude * 4;
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2 + avgAmplitude;
                        ctx.beginPath();
                        drawSmoothCurve(currentPoints, false, height);
                        ctx.stroke();

                        // Draw mirrored line - subtle
                        ctx.shadowBlur = 4;
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        drawSmoothCurve(currentPoints, true, height);
                        ctx.stroke();

                        // Reset
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                };
                draw();
            }
        }

        // Initialize
        new SimplePlayer({{ song.id }});
    </script>
</body>

</html>