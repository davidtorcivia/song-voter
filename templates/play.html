<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ song.base_name }} - {{ branding.title }}</title>
    <meta name="description" content="{{ branding.description }}">
    <link rel="icon" href="{{ branding.favicon or '/static/favicon.ico' }}">
    <link rel="stylesheet" href="/static/style.css">
    <style>
        /* Play page specific styles to ensure proper rendering */
        .play-page .visualizer-container {
            width: 100%;
            height: 120px;
            margin-bottom: 16px;
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--bg-secondary);
        }

        .play-page .visualizer-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .play-page .progress-container {
            position: relative;
            height: 60px;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .play-page .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-warm));
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .play-page .playhead {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background: var(--text-primary);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
            left: 0;
        }

        .play-page .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .play-page .controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        .play-page .control-btn {
            width: 56px;
            height: 56px;
            min-width: 56px;
            min-height: 56px;
            flex-shrink: 0;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .play-page .control-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .play-page .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .play-page .volume-icon {
            font-size: 1rem;
        }

        .play-page .volume-slider {
            width: 100px;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
        }

        .play-page .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .play-subtitle {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 24px;
        }

        /* Mobile: reduce gap so buttons fit */
        @media (max-width: 400px) {
            .play-page .controls-row {
                gap: 12px;
            }

            .play-page .control-btn {
                width: 48px;
                height: 48px;
                min-width: 48px;
                min-height: 48px;
                font-size: 1.25rem;
            }

            .play-page .volume-slider {
                width: 70px;
            }
        }
    </style>
    {% if branding.tracking_code %}{{ branding.tracking_code|safe }}{% endif %}
</head>

<body class="play-page" style="--accent-color: {{ branding.accent_color or '#ffffff' }}">
    <div class="container">
        <h1 id="pageTitle">{{ song.base_name }}</h1>
        <p class="play-subtitle">{{ song.filename }}</p>

        <div class="card">
            <!-- Visualizer -->
            <div class="visualizer-container">
                <canvas id="visualizer"></canvas>
            </div>

            <!-- Audio Controls -->
            <div class="audio-controls">
                <div class="progress-container" id="progressBar">
                    <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                </div>

                <div class="time-display">
                    <span id="currentTime">0:00</span>
                    <span id="totalTime">0:00</span>
                </div>

                <div class="controls-row">
                    <button id="playBtn" class="control-btn">&#9654;</button>
                    <div class="volume-control">
                        <span class="volume-icon">&#9673;</span>
                        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.01"
                            value="1">
                    </div>
                    <button id="castBtn" class="control-btn" style="display: none;" title="Cast">&#8984;</button>
                </div>
            </div>

            <audio id="audioPlayer" preload="auto" crossorigin="anonymous"></audio>
        </div>

        <div class="nav-footer">
            <a href="/" class="nav-link">← Back</a>
            <a href="/results" class="nav-link">Results</a>
        </div>
    </div>

    <script>
        window.VISUALIZER_MODE = '{{ branding.visualizer_mode or "bars" }}';
        window.VISUALIZER_COLOR = '{{ branding.visualizer_color or "" }}';
        window.CAST_ENABLED = {{ 'true' if branding.cast_enabled == 'true' else 'false' }};
        window.CAST_APP_ID = '{{ branding.cast_app_id or "" }}';
        window.CAST_RECEIVER_TYPE = '{{ branding.cast_receiver_type or "default" }}';
        window.OG_IMAGE = '{{ branding.og_image or "" }}';
        window.SITE_TITLE = '{{ branding.title or "Song Voter" }}';
    </script>
    <script>
        class SimplePlayer {
            constructor(song) {
                this.audio = document.getElementById('audioPlayer');
                this.playBtn = document.getElementById('playBtn');

                // Song data for casting
                this.currentSong = song;

                // Waveform elements
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.waveCtx = this.waveformCanvas ? this.waveformCanvas.getContext('2d') : null;
                this.waveData = null;

                this.currentTimeEl = document.getElementById('currentTime');
                this.totalTimeEl = document.getElementById('totalTime');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.castBtn = document.getElementById('castBtn');
                this.canvas = document.getElementById('visualizer');

                this.isPlaying = false;
                this.audioContext = null;
                this.analyser = null;

                // Cast state
                this.castContext = null;
                this.castSession = null;
                this.castReady = false;
                this.useFallbackCast = false;

                // Cache accent color
                this.accentColor = getComputedStyle(document.body).getPropertyValue('--accent-color').trim() || '#a78bfa';

                // Restore saved volume preference
                const savedVolume = localStorage.getItem('song_voter_volume');
                if (savedVolume !== null && this.volumeSlider) {
                    this.volumeSlider.value = savedVolume / 100;
                    this.audio.volume = savedVolume / 100;
                }

                this.init(song.id);
            }

            init(songId) {
                this.audio.src = `/api/songs/${songId}/audio`;
                this.initCasting();

                fetch(`/api/songs/${songId}/waveform`)
                    .then(res => res.json())
                    .then(data => {
                        this.waveData = data;
                        this.drawWaveform();
                    })
                    .catch(() => this.waveData = null);

                // Event listeners
                this.playBtn.addEventListener('click', () => {
                    this.togglePlay();
                    this.playBtn.blur(); // Remove focus highlight on mobile
                });

                if (this.waveformCanvas) {
                    this.waveformCanvas.addEventListener('click', (e) => this.seekFromEvent(e));
                }


                this.volumeSlider.addEventListener('input', () => {
                    // Use gainNode if available (for decoupled visualization)
                    const volume = parseFloat(this.volumeSlider.value);
                    if (this.gainNode) {
                        this.gainNode.gain.value = volume;
                    } else {
                        this.audio.volume = volume;
                    }
                    // Persist volume preference
                    localStorage.setItem('song_voter_volume', Math.round(volume * 100));
                    this.setCastVolume();
                });


                if (this.castBtn) {
                    this.castBtn.addEventListener('click', () => this.promptCast());
                }

                // Seek drag on canvas
                if (this.waveformCanvas) {
                    let isDragging = false;

                    const startDrag = (e) => {
                        isDragging = true;
                        this.seekFromEvent(e);
                    };

                    const endDrag = () => {
                        isDragging = false;
                    };

                    this.waveformCanvas.addEventListener('mousedown', startDrag);
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) this.seekFromEvent(e);
                    });
                    document.addEventListener('mouseup', endDrag);

                    // Hover effect tracking
                    this.hoverX = -1;
                    this.waveformDirty = true; // Initial draw
                    this.waveformCanvas.addEventListener('mousemove', (e) => {
                        const rect = this.waveformCanvas.getBoundingClientRect();
                        this.hoverX = e.clientX - rect.left;
                        this.waveformDirty = true; // Trigger redraw on hover
                    });
                    this.waveformCanvas.addEventListener('mouseleave', () => {
                        this.hoverX = -1;
                        this.waveformDirty = true; // Trigger redraw when leaving
                    });

                    this.waveformCanvas.addEventListener('touchstart', (e) => {
                        startDrag(e.touches[0]);
                    }, { passive: true });
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        this.seekFromEvent(e.touches[0]);
                    }, { passive: true });
                    document.addEventListener('touchend', endDrag);

                    // Start render loop
                    this.animateWaveform();
                }

                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('loadedmetadata', () => {
                    this.totalTimeEl.textContent = this.formatTime(this.audio.duration);
                });
                this.audio.addEventListener('play', () => {
                    this.isPlaying = true;
                    this.playBtn.textContent = '❙❙';
                    if (!this.audioContext) this.setupVisualizer();
                    // Note: resume handled in togglePlay() with await
                });
                this.audio.addEventListener('pause', () => {
                    this.isPlaying = false;
                    this.playBtn.textContent = '▶';
                });

                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                        e.preventDefault();
                        this.togglePlay();
                    }
                });

                this.initCasting();
            }

            initCasting() {
                if (!this.castBtn) return;

                // Show cast button immediately if Remote Playback API exists
                // User wants to initiate cast before playback
                if ('remote' in this.audio) {
                    this.castBtn.style.display = 'flex';
                } else {
                    this.castBtn.style.display = 'none';
                }
            }

            promptCast() {
                if ('remote' in this.audio) {
                    this.audio.remote.prompt().catch(err => {
                        console.log('Cast prompt error:', err);
                    });
                }
            }

            async togglePlay() {
                if (this.isPlaying) {
                    this.audio.pause();
                } else {
                    // Ensure AudioContext is running BEFORE playing
                    if (this.audioContext && this.audioContext.state !== 'running') {
                        try {
                            await this.audioContext.resume();
                        } catch (err) {
                            console.log('AudioContext resume failed:', err);
                        }
                    }
                    this.audio.play();
                }
            }

            seekFromEvent(e) {
                if (!this.waveformCanvas) return;
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = e.clientX !== undefined ? e.clientX : e.pageX;
                let percent = (x - rect.left) / rect.width;
                percent = Math.max(0, Math.min(1, percent));
                if (!isNaN(this.audio.duration)) {
                    this.audio.currentTime = percent * this.audio.duration;
                }
            }

            updateProgress() {
                if (!this.waveformCanvas) return;
                this.currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
                this.waveformDirty = true; // Mark for redraw
            }

            animateWaveform() {
                // Only draw if playing OR if dirty (seek/hover)
                if (this.isPlaying || this.waveformDirty) {
                    this.drawWaveform();
                    this.waveformDirty = false;
                }
                requestAnimationFrame(() => this.animateWaveform());
            }

            drawWaveform() {
                if (!this.waveCtx || !this.waveformCanvas) return;

                const width = this.waveformCanvas.offsetWidth;
                const height = this.waveformCanvas.offsetHeight;

                // Handle retina
                if (this.waveformCanvas.width !== width * window.devicePixelRatio) {
                    this.waveformCanvas.width = width * window.devicePixelRatio;
                    this.waveformCanvas.height = height * window.devicePixelRatio;
                    this.waveCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
                }

                // Clear (transparent background)
                this.waveCtx.clearRect(0, 0, width, height);

                // Use dummy data if not loaded yet
                const data = this.waveData || new Array(100).fill(0.1);
                const barWidth = width / data.length;
                const gap = 0.5; // Small gap

                const progress = this.audio.currentTime / this.audio.duration || 0;
                const progressX = progress * width;

                // Get accent color
                const accentColor = this.accentColor || '#a78bfa';

                // 1. Draw Unplayed Bars
                this.waveCtx.shadowBlur = 0;
                this.waveCtx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                for (let i = 0; i < data.length; i++) {
                    const val = data[i];
                    const x = i * barWidth;
                    const barHeight = Math.max(2, val * height);
                    const y = (height - barHeight) / 2;
                    this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                }

                // 2. Hover (Clipped)
                if (this.hoverX > progressX) {
                    this.waveCtx.save();
                    this.waveCtx.beginPath();
                    this.waveCtx.rect(progressX, 0, this.hoverX - progressX, height);
                    this.waveCtx.clip();

                    this.waveCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    for (let i = 0; i < data.length; i++) {
                        const val = data[i];
                        const x = i * barWidth;
                        if (x + barWidth < progressX) continue;
                        const barHeight = Math.max(2, val * height);
                        const y = (height - barHeight) / 2;
                        this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                    }
                    this.waveCtx.restore();
                }

                // 3. Played (Clipped with Glow)
                this.waveCtx.save();
                this.waveCtx.beginPath();
                this.waveCtx.rect(0, 0, progressX, height);
                this.waveCtx.clip();

                // Create gradient using accent color
                const playedGradient = this.waveCtx.createLinearGradient(0, 0, progressX, 0);
                playedGradient.addColorStop(0, '#ffffff'); // Start bright white
                playedGradient.addColorStop(1, accentColor);

                this.waveCtx.shadowColor = accentColor;
                this.waveCtx.shadowBlur = 6; // Stronger glow for play page
                this.waveCtx.fillStyle = playedGradient;

                for (let i = 0; i < data.length; i++) {
                    const val = data[i];
                    const x = i * barWidth;
                    if (x > progressX) break;
                    const barHeight = Math.max(2, val * height);
                    const y = (height - barHeight) / 2;
                    this.waveCtx.fillRect(x, y, barWidth - gap, barHeight);
                }
                this.waveCtx.restore();

                // Draw playhead line with glow
                if (progress > 0 && progress < 1) {
                    this.waveCtx.shadowBlur = 10;
                    this.waveCtx.shadowColor = '#a78bfa';
                    this.waveCtx.strokeStyle = '#ffffff';
                    this.waveCtx.lineWidth = 2;
                    this.waveCtx.beginPath();
                    this.waveCtx.moveTo(progressX, 0);
                    this.waveCtx.lineTo(progressX, height);
                    this.waveCtx.stroke();
                    this.waveCtx.shadowBlur = 0;
                }
            }

            formatTime(sec) {
                if (isNaN(sec)) return '0:00';
                const m = Math.floor(sec / 60);
                const s = Math.floor(sec % 60);
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            setupVisualizer() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;

                // Pre-allocate typed arrays once (performance optimization)
                const bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(bufferLength);
                this.frequencyData = new Uint8Array(bufferLength);

                // Cache visualizer hue (avoid parsing color every frame)
                const visualizerColor = window.VISUALIZER_COLOR || '';
                if (visualizerColor && visualizerColor !== '') {
                    const vHex = visualizerColor.replace('#', '');
                    const vr = parseInt(vHex.substr(0, 2), 16) / 255;
                    const vg = parseInt(vHex.substr(2, 2), 16) / 255;
                    const vb = parseInt(vHex.substr(4, 2), 16) / 255;
                    const vmax = Math.max(vr, vg, vb), vmin = Math.min(vr, vg, vb);
                    let vh = 0;
                    if (vmax !== vmin) {
                        const vd = vmax - vmin;
                        if (vmax === vr) vh = ((vg - vb) / vd + (vg < vb ? 6 : 0)) / 6;
                        else if (vmax === vg) vh = ((vb - vr) / vd + 2) / 6;
                        else vh = ((vr - vg) / vd + 4) / 6;
                    }
                    this.visualizerHue = Math.round(vh * 360);
                } else {
                    this.visualizerHue = 120; // Default VU green
                }

                // Detect low-power device
                this.isLowPowerDevice = (navigator.hardwareConcurrency || 4) <= 4;

                // Create gain node for volume control AFTER analyser
                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = this.volumeSlider ? parseFloat(this.volumeSlider.value) : 1;

                const source = this.audioContext.createMediaElementSource(this.audio);
                // Route: source -> analyser -> gainNode -> destination
                source.connect(this.analyser);
                this.analyser.connect(this.gainNode);
                this.gainNode.connect(this.audioContext.destination);

                // Set audio element to full volume (gain controls output)
                this.audio.volume = 1;

                this.drawVisualizer();
            }

            drawVisualizer() {
                const ctx = this.canvas.getContext('2d');
                const mode = window.VISUALIZER_MODE || 'bars';

                // Use pre-allocated arrays from setup
                const dataArray = this.dataArray;
                const frequencyData = this.frequencyData;
                const bufferLength = dataArray.length;

                // Trail history for ghost effect (kept in closure)
                const trailHistory = [];
                const maxTrails = this.isLowPowerDevice ? 2 : 5;

                // Use cached hue from setup
                const accentHue = this.visualizerHue || 120;
                const isDefaultAccent = !window.VISUALIZER_COLOR;

                // Bar count based on device capability
                const barCount = this.isLowPowerDevice ? 32 : 64;

                // Helper: Draw smooth bezier curve
                const drawSmoothCurve = (points, mirror, height) => {
                    if (points.length < 2) return;
                    const centerY = height / 2;
                    const getY = (y) => mirror ? centerY + (centerY - y) : y;

                    ctx.moveTo(points[0].x, getY(points[0].y));
                    for (let i = 1; i < points.length - 1; i++) {
                        const xc = (points[i].x + points[i + 1].x) / 2;
                        const yc = (getY(points[i].y) + getY(points[i + 1].y)) / 2;
                        ctx.quadraticCurveTo(points[i].x, getY(points[i].y), xc, yc);
                    }
                    const last = points[points.length - 1];
                    ctx.lineTo(last.x, getY(last.y));
                };

                const draw = () => {
                    requestAnimationFrame(draw);

                    // Skip drawing when paused (major performance win)
                    if (!this.isPlaying) {
                        return;
                    }

                    const container = this.canvas.parentElement;
                    const width = container.offsetWidth;
                    const height = container.offsetHeight;

                    // Set canvas size for retina
                    this.canvas.width = width * window.devicePixelRatio;
                    this.canvas.height = height * window.devicePixelRatio;
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                    // Clear for fully transparent background
                    ctx.clearRect(0, 0, width, height);

                    // Get appropriate data using pre-allocated arrays
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.analyser.getByteFrequencyData(frequencyData);

                    // Draw bars first if mode is 'bars' or 'both'
                    if (mode === 'bars' || mode === 'both') {
                        const barWidth = (width / barCount) * 0.85;
                        const gap = (width / barCount) * 0.15;

                        for (let i = 0; i < barCount; i++) {
                            const idx = Math.floor(i * bufferLength / barCount);
                            const value = frequencyData[idx] / 255;
                            const barHeight = value * height * 0.9;
                            const x = i * (barWidth + gap);

                            if (mode === 'both') {
                                // In both mode: bars are a subtle glowing backdrop
                                const hueShift = (i / barCount) * 40 - 20;
                                const sat = 25 + value * 30;
                                const light = 20 + value * 25;

                                // Create vertical gradient for each bar
                                const barGrad = ctx.createLinearGradient(0, height, 0, height - barHeight);
                                barGrad.addColorStop(0, `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.6)`);
                                barGrad.addColorStop(1, `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.1)`);

                                ctx.fillStyle = barGrad;
                            } else {
                                // Bars-only mode: full vibrant bars
                                const hueShift = (i / barCount) * 30 - 15;
                                const sat = 50 + value * 40;
                                const light = 35 + value * 40;
                                ctx.fillStyle = `hsla(${accentHue + hueShift}, ${sat}%, ${light}%, 0.85)`;
                            }
                            ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                        }
                    }

                    // Draw oscilloscope if mode is 'wave' or 'both'
                    if (mode === 'wave' || mode === 'both') {
                        // Calculate average amplitude for reactive effects
                        let avgAmplitude = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            avgAmplitude += Math.abs(dataArray[i] - 128);
                        }
                        avgAmplitude = (avgAmplitude / bufferLength) / 128;

                        // Store current frame points
                        const currentPoints = [];
                        const sliceWidth = width / bufferLength;

                        for (let i = 0; i < bufferLength; i++) {
                            const v = dataArray[i] / 128.0;
                            const y = (v * height) / 2;
                            currentPoints.push({ x: i * sliceWidth, y });
                        }

                        // Add to trail history
                        trailHistory.unshift(currentPoints);
                        if (trailHistory.length > maxTrails) trailHistory.pop();

                        // Draw trails (fading) - Green VU gradient
                        for (let t = trailHistory.length - 1; t >= 0; t--) {
                            const points = trailHistory[t];
                            const trailAlpha = (1 - t / maxTrails) * 0.2;

                            if (t > 0) {
                                ctx.strokeStyle = `hsla(${accentHue}, 60%, 50%, ${trailAlpha})`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                drawSmoothCurve(points, false, height);
                                ctx.stroke();
                            }
                        }

                        // In 'both' mode, reduce oscilloscope prominence
                        const isBothMode = mode === 'both';
                        const lineOpacity = isBothMode ? 0.7 : 1;
                        const glowStrength = isBothMode ? 4 : 8;

                        // Green VU gradient for oscilloscope (no blue/cyan)
                        const gradient = ctx.createLinearGradient(0, 0, width, 0);
                        const satBoost = 65 + avgAmplitude * 25;
                        const lightBoost = 45 + avgAmplitude * 30;
                        gradient.addColorStop(0, `hsl(${accentHue - 15}, ${satBoost}%, ${lightBoost}%)`);
                        gradient.addColorStop(0.5, `hsl(${accentHue}, ${satBoost + 10}%, ${lightBoost + 10}%)`);
                        gradient.addColorStop(1, `hsl(${accentHue + 15}, ${satBoost}%, ${lightBoost}%)`);

                        // Draw main oscilloscope line with green glow
                        ctx.globalAlpha = lineOpacity;
                        ctx.shadowColor = `hsl(${accentHue}, 60%, 50%)`;
                        ctx.shadowBlur = glowStrength;
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = isBothMode ? 1.5 + avgAmplitude * 0.5 : 2 + avgAmplitude;
                        ctx.beginPath();
                        drawSmoothCurve(currentPoints, false, height);
                        ctx.stroke();

                        // Draw mirrored line - subtle green
                        ctx.strokeStyle = `hsla(${accentHue}, 50%, 40%, 0.3)`;
                        ctx.shadowBlur = 2;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        drawSmoothCurve(currentPoints, true, height);
                        ctx.stroke();

                        // Reset
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                };
                draw();
            }
            formatTime(seconds) {
                if (isNaN(seconds)) return '0:00';
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            // Cast SDK Implementation
            initCasting() {
                if (!this.castBtn) return;

                // Check if Cast is enabled via admin settings
                if (!window.CAST_ENABLED || !window.CAST_APP_ID) {
                    // Fall back to Remote Playback API if Cast SDK not configured
                    if ('remote' in this.audio) {
                        this.audio.remote.watchAvailability((available) => {
                            this.castBtn.style.display = available ? 'inline-flex' : 'none';
                        }).catch(() => {
                            this.castBtn.style.display = 'inline-flex';
                        });
                    } else {
                        this.castBtn.style.display = 'none';
                    }
                    return;
                }

                // Show button immediately
                this.castBtn.style.display = 'inline-flex';

                console.log('Play Page: Initializing Cast with:', {
                    enabled: window.CAST_ENABLED,
                    appId: window.CAST_APP_ID,
                    type: window.CAST_RECEIVER_TYPE
                });

                // Load Cast SDK dynamically
                this.loadCastSDK().then(() => {
                    this.initCastContext();
                }).catch(err => {
                    console.log('Cast SDK load failed, falling back to Remote Playback:', err);
                    // Fallback to Remote Playback API
                    this.useFallbackCast = true;
                    this.castBtn.style.display = 'inline-flex';
                });
            }

            loadCastSDK() {
                return new Promise((resolve, reject) => {
                    // Check if already loaded
                    if (window.cast && window.cast.framework) {
                        resolve();
                        return;
                    }

                    // Load the Cast SDK
                    const script = document.createElement('script');
                    script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
                    script.async = true;

                    window['__onGCastApiAvailable'] = (isAvailable) => {
                        if (isAvailable) {
                            resolve();
                        } else {
                            reject(new Error('Cast API not available'));
                        }
                    };

                    script.onerror = () => reject(new Error('Failed to load Cast SDK'));
                    document.head.appendChild(script);
                });
            }

            initCastContext() {
                const castContext = cast.framework.CastContext.getInstance();

                // Determine receiver application ID
                let receiverAppId = window.CAST_APP_ID;
                if (window.CAST_RECEIVER_TYPE === 'default') {
                    receiverAppId = chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID;
                }

                castContext.setOptions({
                    receiverApplicationId: receiverAppId,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });

                // Listen for cast state changes (device availability)
                castContext.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    (event) => {
                        console.log('Cast state:', event.castState);
                        // Show button when cast devices are available or connected
                        if (event.castState !== cast.framework.CastState.NO_DEVICES_AVAILABLE) {
                            this.castBtn.style.display = 'inline-flex';
                        }
                    }
                );

                // Listen for session state changes
                castContext.addEventListener(
                    cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
                    (event) => this.onCastSessionStateChanged(event)
                );

                // Store reference
                this.castContext = castContext;
                this.castReady = true;

                // Check initial state
                const initialState = castContext.getCastState();
                if (initialState !== cast.framework.CastState.NO_DEVICES_AVAILABLE) {
                    this.castBtn.style.display = 'inline-flex';
                }
            }

            onCastSessionStateChanged(event) {
                const session = cast.framework.CastContext.getInstance().getCurrentSession();

                switch (event.sessionState) {
                    case cast.framework.SessionState.SESSION_STARTED:
                    case cast.framework.SessionState.SESSION_RESUMED:
                        this.castSession = session;
                        this.castBtn.classList.add('casting');
                        this.castBtn.title = 'Casting...';
                        // Load current media to cast device
                        if (this.currentSong) {
                            this.loadMediaToCast();
                        }
                        break;

                    case cast.framework.SessionState.SESSION_ENDED:
                        this.castSession = null;
                        this.castBtn.classList.remove('casting');
                        this.castBtn.title = 'Cast';
                        break;
                }
            }

            loadMediaToCast() {
                if (!this.castSession || !this.currentSong) return;

                const mediaInfo = new chrome.cast.media.MediaInfo(
                    window.location.origin + `/api/songs/${this.currentSong.id}/audio`,
                    'audio/mpeg'
                );

                // Add metadata for display on TV
                mediaInfo.metadata = new chrome.cast.media.MusicTrackMediaMetadata();
                mediaInfo.metadata.title = this.currentSong.base_name || this.currentSong.filename;
                mediaInfo.metadata.artist = window.SITE_TITLE || 'Song Voter';

                // Add OG image if available
                if (window.OG_IMAGE) {
                    const ogImageUrl = window.OG_IMAGE.startsWith('http')
                        ? window.OG_IMAGE
                        : window.location.origin + window.OG_IMAGE;
                    mediaInfo.metadata.images = [new chrome.cast.Image(ogImageUrl)];
                }

                // Add waveform URL for visualizer on receiver
                mediaInfo.customData = {
                    waveformUrl: window.location.origin + `/api/songs/${this.currentSong.id}/waveform`
                };

                const request = new chrome.cast.media.LoadRequest(mediaInfo);
                request.currentTime = this.audio.currentTime;
                request.autoplay = this.isPlaying;

                this.castSession.loadMedia(request).then(() => {
                    console.log('Media loaded to cast device');
                    // Sync volume after media loads
                    setTimeout(() => this.setCastVolume(), 500);
                }).catch(err => {
                    console.log('Cast media load error:', err);
                });
            }

            setCastVolume() {
                if (!this.castSession) return;

                // Get volume from slider (0-1 range)
                const volume = this.volumeSlider ? parseFloat(this.volumeSlider.value) : 1;

                try {
                    this.castSession.setVolume(volume);
                    console.log('Cast volume set to:', volume);
                } catch (err) {
                    console.log('Cast volume error:', err);
                }
            }

            promptCast() {
                // If SDK not ready yet, try Remote Playback API
                if (!this.castReady || this.useFallbackCast) {
                    if ('remote' in this.audio) {
                        this.audio.remote.prompt().catch(err => {
                            console.log('Cast prompt error:', err);
                        });
                    }
                    return;
                }

                // Use Cast SDK
                if (this.castContext) {
                    try {
                        this.castContext.requestSession();
                    } catch (err) {
                        console.log('Cast session error:', err);
                        // Fallback: try Remote Playback API
                        if ('remote' in this.audio) {
                            this.audio.remote.prompt().catch(e => console.log('Fallback cast error:', e));
                        }
                    }
                }
            }
        }

        // Initialize
        new SimplePlayer({{ song | tojson }});
    </script>
</body>

</html>