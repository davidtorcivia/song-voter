<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song Voter Cast Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            position: relative;
        }

        /* Album art / OG image */
        .artwork {
            width: 300px;
            height: 300px;
            border-radius: 12px;
            object-fit: cover;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .artwork.loaded {
            opacity: 1;
        }

        /* Song title */
        .title {
            font-size: 48px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 12px;
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Artist / site name */
        .artist {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 60px;
        }

        /* Progress bar */
        .progress-container {
            width: 60%;
            max-width: 800px;
            height: 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            width: 0%;
            border-radius: 4px;
        }

        /* Time display */
        .time-display {
            width: 60%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.5);
            font-variant-numeric: tabular-nums;
        }

        /* Visualizer canvas */
        .visualizer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            opacity: 0.7;
        }

        /* Idle state */
        .idle-message {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.3);
            display: none;
        }

        body.idle .container>*:not(.idle-message) {
            display: none;
        }

        body.idle .idle-message {
            display: block;
        }

        body.idle .visualizer {
            opacity: 0.3;
        }
    </style>
</head>

<body class="idle">
    <div class="container">
        <img class="artwork" id="artwork" src="" alt="">
        <div class="title" id="title">-</div>
        <div class="artist" id="artist">Song Voter</div>

        <div class="progress-container">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="time-display">
            <span id="currentTime">0:00</span>
            <span id="totalTime">0:00</span>
        </div>

        <div class="idle-message">Waiting for media...</div>
    </div>

    <canvas class="visualizer" id="visualizer"></canvas>

    <!-- Cast Receiver SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        // Initialize Cast Receiver
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // DOM Elements
        const artwork = document.getElementById('artwork');
        const titleEl = document.getElementById('title');
        const artistEl = document.getElementById('artist');
        const progressFill = document.getElementById('progressFill');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // State
        let isPlaying = false;
        let barHeights = [];
        let targetHeights = [];
        const barCount = 64;

        // Initialize bar heights
        for (let i = 0; i < barCount; i++) {
            barHeights.push(5);
            targetHeights.push(5);
        }

        // Format time helper
        function formatTime(sec) {
            if (isNaN(sec)) return '0:00';
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Resize canvas for retina
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Simulated visualizer - generates random bar heights when playing
        function updateTargetHeights() {
            if (isPlaying) {
                for (let i = 0; i < barCount; i++) {
                    // Generate smooth random heights with some correlation between neighbors
                    const base = 20 + Math.random() * 60;
                    const wave = Math.sin(Date.now() / 500 + i * 0.2) * 15;
                    targetHeights[i] = Math.max(5, base + wave);
                }
            } else {
                // Idle state - small random heights
                for (let i = 0; i < barCount; i++) {
                    targetHeights[i] = 3 + Math.random() * 8;
                }
            }
        }

        // Draw visualizer bars with smooth animation
        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);

            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            ctx.clearRect(0, 0, width, height);

            const barWidth = (width / barCount) * 0.8;
            const gap = (width / barCount) * 0.2;

            for (let i = 0; i < barCount; i++) {
                // Smooth interpolation toward target
                barHeights[i] += (targetHeights[i] - barHeights[i]) * 0.15;

                const barHeight = barHeights[i];
                const x = i * (barWidth + gap);

                if (isPlaying) {
                    // Green VU meter gradient when playing
                    const hue = 120 + (i / barCount) * 30 - 15;
                    const normalizedHeight = barHeight / 80;
                    const sat = 50 + normalizedHeight * 40;
                    const light = 35 + normalizedHeight * 40;
                    ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.85)`;
                } else {
                    // Dim gray when idle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                }

                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            }
        }

        // Update target heights periodically
        setInterval(updateTargetHeights, 100);

        // Start animation
        drawVisualizer();

        // Handle media load
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (request) => {
                document.body.classList.remove('idle');

                const media = request.media;

                // Update title
                if (media.metadata) {
                    titleEl.textContent = media.metadata.title || 'Unknown';
                    artistEl.textContent = media.metadata.artist || 'Song Voter';

                    // Load artwork
                    if (media.metadata.images && media.metadata.images.length > 0) {
                        const imgUrl = media.metadata.images[0].url;
                        artwork.src = imgUrl;
                        artwork.classList.add('loaded');
                    } else {
                        artwork.classList.remove('loaded');
                    }
                }

                return request;
            }
        );

        // Update progress during playback - use interval for reliability
        setInterval(() => {
            try {
                const currentTime = playerManager.getCurrentTimeSec();
                const duration = playerManager.getDurationSec();

                if (duration > 0 && !isNaN(currentTime)) {
                    const progress = (currentTime / duration) * 100;
                    progressFill.style.width = `${progress}%`;
                    currentTimeEl.textContent = formatTime(currentTime);
                    totalTimeEl.textContent = formatTime(duration);
                }
            } catch (e) {
                // Player not ready
            }
        }, 500);

        // Handle play/pause state
        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYER_STATE_CHANGED,
            (event) => {
                const state = event.fieldValue;
                // Check for PLAYING state
                isPlaying = (state === 'PLAYING' || state === cast.framework.ui.State.PLAYING);
                console.log('Player state:', state, 'isPlaying:', isPlaying);
            }
        );

        // Handle media ended
        playerManager.addEventListener(
            cast.framework.events.EventType.MEDIA_FINISHED,
            () => {
                isPlaying = false;
                progressFill.style.width = '0%';
            }
        );

        // Start receiver
        context.start();
    </script>
</body>

</html>