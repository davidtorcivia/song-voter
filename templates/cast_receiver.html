<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song Voter Cast Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            position: relative;
        }

        /* Album art / OG image */
        .artwork {
            width: 300px;
            height: 300px;
            border-radius: 12px;
            object-fit: cover;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .artwork.loaded {
            opacity: 1;
        }

        /* Song title */
        .title {
            font-size: 48px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 12px;
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Artist / site name */
        .artist {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 60px;
        }

        /* Progress bar */
        .progress-container {
            width: 60%;
            max-width: 800px;
            height: 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            width: 0%;
            border-radius: 4px;
        }

        /* Time display */
        .time-display {
            width: 60%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.5);
            font-variant-numeric: tabular-nums;
        }

        /* Visualizer canvas */
        .visualizer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            opacity: 0.8;
        }

        /* Idle state */
        .idle-message {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.3);
            display: none;
        }

        body.idle .container>*:not(.idle-message) {
            display: none;
        }

        body.idle .idle-message {
            display: block;
        }

        body.idle .visualizer {
            opacity: 0.3;
        }
    </style>
</head>

<body class="idle">
    <div class="container">
        <img class="artwork" id="artwork" src="" alt="">
        <div class="title" id="title">-</div>
        <div class="artist" id="artist">Song Voter</div>

        <div class="progress-container">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="time-display">
            <span id="currentTime">0:00</span>
            <span id="totalTime">0:00</span>
        </div>

        <div class="idle-message">Waiting for media...</div>
    </div>

    <canvas class="visualizer" id="visualizer"></canvas>

    <!-- Cast Receiver SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        // Initialize Cast Receiver
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // DOM Elements
        const artwork = document.getElementById('artwork');
        const titleEl = document.getElementById('title');
        const artistEl = document.getElementById('artist');
        const progressFill = document.getElementById('progressFill');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // State
        let isPlaying = false;
        let waveformData = null;
        let currentProgress = 0;
        let duration = 0;

        const barCount = 64;
        let displayHeights = new Array(barCount).fill(5);

        // Format time helper
        function formatTime(sec) {
            if (isNaN(sec)) return '0:00';
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Resize canvas for retina
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Get target heights from waveform data based on current position
        function getWaveformHeights(progress) {
            if (!waveformData || waveformData.length === 0) {
                // Fallback to random when no waveform
                return new Array(barCount).fill(0).map(() => isPlaying ? 20 + Math.random() * 50 : 5);
            }

            const heights = [];
            const waveLen = waveformData.length;

            // Calculate the center position in the waveform
            const centerIdx = Math.floor(progress * waveLen);

            // Show a window of bars around current position
            const windowSize = Math.floor(waveLen * 0.1); // 10% of track visible

            for (let i = 0; i < barCount; i++) {
                // Map bar position to waveform index
                const offset = (i / barCount - 0.5) * windowSize;
                const idx = Math.max(0, Math.min(waveLen - 1, Math.round(centerIdx + offset)));
                const value = waveformData[idx] || 0;

                // Scale to canvas height (waveform values are 0-1)
                heights.push(value * 80 + 5);
            }

            return heights;
        }

        // Draw visualizer bars with smooth animation
        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);

            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            ctx.clearRect(0, 0, width, height);

            const barWidth = (width / barCount) * 0.8;
            const gap = (width / barCount) * 0.2;

            // Get target heights based on waveform and progress
            const targetHeights = getWaveformHeights(currentProgress);

            for (let i = 0; i < barCount; i++) {
                // Smooth interpolation toward target
                displayHeights[i] += (targetHeights[i] - displayHeights[i]) * 0.2;

                const barHeight = displayHeights[i];
                const x = i * (barWidth + gap);

                // Determine if this bar is "played" (left of center)
                const isPlayed = i < barCount / 2;

                if (isPlaying || waveformData) {
                    // Green VU meter gradient
                    const hue = 120 + (i / barCount) * 30 - 15;
                    const normalizedHeight = barHeight / 85;
                    const sat = 50 + normalizedHeight * 40;
                    const light = isPlayed ? (35 + normalizedHeight * 40) : (25 + normalizedHeight * 25);
                    const alpha = isPlayed ? 0.9 : 0.5;
                    ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
                } else {
                    // Dim gray when idle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                }

                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            }

            // Draw playhead line at center
            if (isPlaying && waveformData) {
                const centerX = width / 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, height);
                ctx.stroke();
            }
        }

        // Start animation
        drawVisualizer();

        // Handle media load
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (request) => {
                document.body.classList.remove('idle');

                const media = request.media;

                // Update title
                if (media.metadata) {
                    titleEl.textContent = media.metadata.title || 'Unknown';
                    artistEl.textContent = media.metadata.artist || 'Song Voter';

                    // Load artwork
                    if (media.metadata.images && media.metadata.images.length > 0) {
                        const imgUrl = media.metadata.images[0].url;
                        artwork.src = imgUrl;
                        artwork.classList.add('loaded');
                    } else {
                        artwork.classList.remove('loaded');
                    }
                }

                // Load waveform data if provided
                if (media.customData && media.customData.waveformUrl) {
                    fetch(media.customData.waveformUrl)
                        .then(res => res.json())
                        .then(data => {
                            waveformData = data;
                            console.log('Waveform loaded:', data.length, 'points');
                        })
                        .catch(err => {
                            console.log('Waveform load error:', err);
                            waveformData = null;
                        });
                } else {
                    waveformData = null;
                }

                return request;
            }
        );

        // Update progress during playback
        setInterval(() => {
            try {
                const currentTime = playerManager.getCurrentTimeSec();
                duration = playerManager.getDurationSec();

                if (duration > 0 && !isNaN(currentTime)) {
                    currentProgress = currentTime / duration;
                    progressFill.style.width = `${currentProgress * 100}%`;
                    currentTimeEl.textContent = formatTime(currentTime);
                    totalTimeEl.textContent = formatTime(duration);
                }
            } catch (e) {
                // Player not ready
            }
        }, 100); // Faster updates for smoother visualizer

        // Handle play/pause state
        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYER_STATE_CHANGED,
            (event) => {
                const state = event.fieldValue;
                isPlaying = (state === 'PLAYING' || state === cast.framework.ui.State.PLAYING);
                console.log('Player state:', state, 'isPlaying:', isPlaying);
            }
        );

        // Handle media ended
        playerManager.addEventListener(
            cast.framework.events.EventType.MEDIA_FINISHED,
            () => {
                isPlaying = false;
                currentProgress = 0;
                progressFill.style.width = '0%';
                waveformData = null;
            }
        );

        // Start receiver
        context.start();
    </script>
</body>

</html>